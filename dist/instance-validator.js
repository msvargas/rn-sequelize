'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

const _ = require('lodash');

const Utils = require('./utils');

const sequelizeError = require('./errors');

const Promise = require('./promise');

const DataTypes = require('./data-types');

const BelongsTo = require('./associations/belongs-to');

const validator = require('./utils/validator-extras').validator;
/**
 * Instance Validator.
 *
 * @param {Instance} modelInstance The model instance.
 * @param {Object} options A dictionary with options.
 *
 * @private
 */


let InstanceValidator = /*#__PURE__*/function () {
  function InstanceValidator(modelInstance, options) {
    _classCallCheck(this, InstanceValidator);

    options = _.clone(options) || {};

    if (options.fields && !options.skip) {
      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);
    } // assign defined and default options


    this.options = _.defaults(options, {
      skip: [],
      hooks: true
    });
    this.modelInstance = modelInstance;
    /**
     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`
     * @name validator
     * @private
     */

    this.validator = validator;
    /**
     *  All errors will be stored here from the validations.
     *
     * @type {Array} Will contain keys that correspond to attributes which will
     *   be Arrays of Errors.
     * @private
     */

    this.errors = [];
    /**
     * @type {boolean} Indicates if validations are in progress
     * @private
     */

    this.inProgress = false;
  }
  /**
   * The main entry point for the Validation module, invoke to start the dance.
   *
   * @returns {Promise}
   * @private
   */


  _createClass(InstanceValidator, [{
    key: "_validate",
    value: function _validate() {
      if (this.inProgress) throw new Error('Validations already in progress.');
      this.inProgress = true;
      return Promise.all([this._perAttributeValidators().reflect(), this._customValidators().reflect()]).then(() => {
        if (this.errors.length) {
          throw new sequelizeError.ValidationError(null, this.errors);
        }
      });
    }
    /**
     * Invoke the Validation sequence and run validation hooks if defined
     *   - Before Validation Model Hooks
     *   - Validation
     *   - On validation success: After Validation Model Hooks
     *   - On validation failure: Validation Failed Model Hooks
     *
     * @returns {Promise}
     * @private
     */

  }, {
    key: "validate",
    value: function validate() {
      return this.options.hooks ? this._validateAndRunHooks() : this._validate();
    }
    /**
     * Invoke the Validation sequence and run hooks
     *   - Before Validation Model Hooks
     *   - Validation
     *   - On validation success: After Validation Model Hooks
     *   - On validation failure: Validation Failed Model Hooks
     *
     * @returns {Promise}
     * @private
     */

  }, {
    key: "_validateAndRunHooks",
    value: function _validateAndRunHooks() {
      const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);
      return runHooks('beforeValidate', this.modelInstance, this.options).then(() => this._validate().catch(error => runHooks('validationFailed', this.modelInstance, this.options, error).then(newError => {
        throw newError || error;
      }))).then(() => runHooks('afterValidate', this.modelInstance, this.options)).return(this.modelInstance);
    }
    /**
     * Will run all the validators defined per attribute (built-in validators and custom validators)
     *
     * @returns {Promise<Array.<Promise.PromiseInspection>>} A promise from .reflect().
     * @private
     */

  }, {
    key: "_perAttributeValidators",
    value: function _perAttributeValidators() {
      // promisify all attribute invocations
      const validators = [];

      _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {
        if (this.options.skip.includes(field)) {
          return;
        }

        const value = this.modelInstance.dataValues[field];

        if (value instanceof Utils.SequelizeMethod) {
          return;
        }

        if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {
          // perform validations based on schema
          this._validateSchema(rawAttribute, field, value);
        }

        if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {
          validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull).reflect());
        }
      });

      return Promise.all(validators);
    }
    /**
     * Will run all the custom validators defined in the model's options.
     *
     * @returns {Promise<Array.<Promise.PromiseInspection>>} A promise from .reflect().
     * @private
     */

  }, {
    key: "_customValidators",
    value: function _customValidators() {
      const validators = [];

      _.each(this.modelInstance._modelOptions.validate, (validator, validatorType) => {
        if (this.options.skip.includes(validatorType)) {
          return;
        }

        const valprom = this._invokeCustomValidator(validator, validatorType) // errors are handled in settling, stub this
        .catch(() => {}).reflect();

        validators.push(valprom);
      });

      return Promise.all(validators);
    }
    /**
     * Validate a single attribute with all the defined built-in validators and custom validators.
     *
     * @private
     *
     * @param {*} value Anything.
     * @param {string} field The field name.
     * @param {boolean} allowNull Whether or not the schema allows null values
     *
     * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.
     */

  }, {
    key: "_singleAttrValidate",
    value: function _singleAttrValidate(value, field, allowNull) {
      // If value is null and allowNull is false, no validators should run (see #9143)
      if ((value === null || value === undefined) && !allowNull) {
        // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.
        return Promise.resolve();
      } // Promisify each validator


      const validators = [];

      _.forIn(this.modelInstance.validators[field], (test, validatorType) => {
        if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {
          // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object
          if (typeof test === 'object' && test !== null && test.msg) {
            test = {
              msg: test.msg
            };
          } else if (test === true) {
            test = {};
          }
        } // Custom validators should always run, except if value is null and allowNull is false (see #9143)


        if (typeof test === 'function') {
          validators.push(this._invokeCustomValidator(test, validatorType, true, value, field).reflect());
          return;
        } // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).


        if (value === null || value === undefined) {
          return;
        }

        const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field); // errors are handled in settling, stub this


        validatorPromise.catch(() => {});
        validators.push(validatorPromise.reflect());
      });

      return Promise.all(validators).then(results => this._handleReflectedResult(field, value, results));
    }
    /**
     * Prepare and invoke a custom validator.
     *
     * @private
     *
     * @param {Function} validator The custom validator.
     * @param {string} validatorType the custom validator type (name).
     * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute
     * @param {*} optValue value for attribute
     * @param {string} optField field for attribute
     *
     * @returns {Promise} A promise.
     */

  }, {
    key: "_invokeCustomValidator",
    value: function _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {
      let validatorFunction = null; // the validation function to call

      let isAsync = false;
      const validatorArity = validator.length; // check if validator is async and requires a callback

      let asyncArity = 1;
      let errorKey = validatorType;
      let invokeArgs;

      if (optAttrDefined) {
        asyncArity = 2;
        invokeArgs = optValue;
        errorKey = optField;
      }

      if (validatorArity === asyncArity) {
        isAsync = true;
      }

      if (isAsync) {
        if (optAttrDefined) {
          validatorFunction = Promise.promisify(validator.bind(this.modelInstance, invokeArgs));
        } else {
          validatorFunction = Promise.promisify(validator.bind(this.modelInstance));
        }

        return validatorFunction().catch(e => this._pushError(false, errorKey, e, optValue, validatorType));
      }

      return Promise.try(() => validator.call(this.modelInstance, invokeArgs)).catch(e => this._pushError(false, errorKey, e, optValue, validatorType));
    }
    /**
     * Prepare and invoke a build-in validator.
     *
     * @private
     *
     * @param {*} value Anything.
     * @param {*} test The test case.
     * @param {string} validatorType One of known to Sequelize validators.
     * @param {string} field The field that is being validated
     *
     * @returns {Object} An object with specific keys to invoke the validator.
     */

  }, {
    key: "_invokeBuiltinValidator",
    value: function _invokeBuiltinValidator(value, test, validatorType, field) {
      return Promise.try(() => {
        // Cast value as string to pass new Validator.js string requirement
        const valueString = String(value); // check if Validator knows that kind of validation test

        if (typeof validator[validatorType] !== 'function') {
          throw new Error(`Invalid validator function: ${validatorType}`);
        }

        const validatorArgs = this._extractValidatorArgs(test, validatorType, field);

        if (!validator[validatorType](valueString, ...validatorArgs)) {
          throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), {
            validatorName: validatorType,
            validatorArgs
          });
        }
      });
    }
    /**
     * Will extract arguments for the validator.
     *
     * @param {*} test The test case.
     * @param {string} validatorType One of known to Sequelize validators.
     * @param {string} field The field that is being validated.
     *
     * @private
     */

  }, {
    key: "_extractValidatorArgs",
    value: function _extractValidatorArgs(test, validatorType, field) {
      let validatorArgs = test.args || test;
      const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');

      if (!Array.isArray(validatorArgs)) {
        if (validatorType === 'isImmutable') {
          validatorArgs = [validatorArgs, field, this.modelInstance];
        } else if (isLocalizedValidator || validatorType === 'isIP') {
          validatorArgs = [];
        } else {
          validatorArgs = [validatorArgs];
        }
      } else {
        validatorArgs = validatorArgs.slice(0);
      }

      return validatorArgs;
    }
    /**
     * Will validate a single field against its schema definition (isnull).
     *
     * @param {Object} rawAttribute As defined in the Schema.
     * @param {string} field The field name.
     * @param {*} value anything.
     *
     * @private
     */

  }, {
    key: "_validateSchema",
    value: function _validateSchema(rawAttribute, field, value) {
      if (rawAttribute.allowNull === false && (value === null || value === undefined)) {
        const association = _.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);

        if (!association || !this.modelInstance.get(association.associationAccessor)) {
          const validators = this.modelInstance.validators[field];

          const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);

          this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, 'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field, value, this.modelInstance, 'is_null'));
        }
      }

      if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {
        if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {
          this.errors.push(new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, 'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field, value, this.modelInstance, 'not_a_string'));
        }
      }
    }
    /**
     * Handles the returned result of a Promise.reflect.
     *
     * If errors are found it populates this.error.
     *
     * @param {string} field The attribute name.
     * @param {string|number} value The data value.
     * @param {Array<Promise.PromiseInspection>} promiseInspections objects.
     *
     * @private
     */

  }, {
    key: "_handleReflectedResult",
    value: function _handleReflectedResult(field, value, promiseInspections) {
      for (const promiseInspection of promiseInspections) {
        if (promiseInspection.isRejected()) {
          const rejection = promiseInspection.error();
          const isBuiltIn = !!rejection.validatorName;

          this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);
        }
      }
    }
    /**
     * Signs all errors retaining the original.
     *
     * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.
     * @param {string}        errorKey    - name of invalid attribute.
     * @param {Error|string}  rawError    - The original error.
     * @param {string|number} value       - The data that triggered the error.
     * @param {string}        fnName      - Name of the validator, if any
     * @param {Array}         fnArgs      - Arguments for the validator [function], if any
     *
     * @private
     */

  }, {
    key: "_pushError",
    value: function _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {
      const message = rawError.message || rawError || 'Validation error';
      const error = new sequelizeError.ValidationErrorItem(message, 'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,
      errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : undefined, isBuiltin ? fnArgs : undefined);
      error[InstanceValidator.RAW_KEY_NAME] = rawError;
      this.errors.push(error);
    }
  }]);

  return InstanceValidator;
}();
/**
 * @define {string} The error key for arguments as passed by custom validators
 * @private
 */


InstanceValidator.RAW_KEY_NAME = 'original';
module.exports = InstanceValidator;
module.exports.InstanceValidator = InstanceValidator;
module.exports.default = InstanceValidator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9pbnN0YW5jZS12YWxpZGF0b3IuanMiXSwibmFtZXMiOlsiXyIsInJlcXVpcmUiLCJVdGlscyIsInNlcXVlbGl6ZUVycm9yIiwiUHJvbWlzZSIsIkRhdGFUeXBlcyIsIkJlbG9uZ3NUbyIsInZhbGlkYXRvciIsIkluc3RhbmNlVmFsaWRhdG9yIiwibW9kZWxJbnN0YW5jZSIsIm9wdGlvbnMiLCJjbG9uZSIsImZpZWxkcyIsInNraXAiLCJkaWZmZXJlbmNlIiwiT2JqZWN0Iiwia2V5cyIsImNvbnN0cnVjdG9yIiwicmF3QXR0cmlidXRlcyIsImRlZmF1bHRzIiwiaG9va3MiLCJlcnJvcnMiLCJpblByb2dyZXNzIiwiRXJyb3IiLCJhbGwiLCJfcGVyQXR0cmlidXRlVmFsaWRhdG9ycyIsInJlZmxlY3QiLCJfY3VzdG9tVmFsaWRhdG9ycyIsInRoZW4iLCJsZW5ndGgiLCJWYWxpZGF0aW9uRXJyb3IiLCJfdmFsaWRhdGVBbmRSdW5Ib29rcyIsIl92YWxpZGF0ZSIsInJ1bkhvb2tzIiwiYmluZCIsImNhdGNoIiwiZXJyb3IiLCJuZXdFcnJvciIsInJldHVybiIsInZhbGlkYXRvcnMiLCJmb3JJbiIsInJhd0F0dHJpYnV0ZSIsImZpZWxkIiwiaW5jbHVkZXMiLCJ2YWx1ZSIsImRhdGFWYWx1ZXMiLCJTZXF1ZWxpemVNZXRob2QiLCJfYXV0b0dlbmVyYXRlZCIsImF1dG9JbmNyZW1lbnQiLCJfdmFsaWRhdGVTY2hlbWEiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJwdXNoIiwiX3NpbmdsZUF0dHJWYWxpZGF0ZSIsImFsbG93TnVsbCIsImVhY2giLCJfbW9kZWxPcHRpb25zIiwidmFsaWRhdGUiLCJ2YWxpZGF0b3JUeXBlIiwidmFscHJvbSIsIl9pbnZva2VDdXN0b21WYWxpZGF0b3IiLCJ1bmRlZmluZWQiLCJyZXNvbHZlIiwidGVzdCIsIm1zZyIsInZhbGlkYXRvclByb21pc2UiLCJfaW52b2tlQnVpbHRpblZhbGlkYXRvciIsInJlc3VsdHMiLCJfaGFuZGxlUmVmbGVjdGVkUmVzdWx0Iiwib3B0QXR0ckRlZmluZWQiLCJvcHRWYWx1ZSIsIm9wdEZpZWxkIiwidmFsaWRhdG9yRnVuY3Rpb24iLCJpc0FzeW5jIiwidmFsaWRhdG9yQXJpdHkiLCJhc3luY0FyaXR5IiwiZXJyb3JLZXkiLCJpbnZva2VBcmdzIiwicHJvbWlzaWZ5IiwiZSIsIl9wdXNoRXJyb3IiLCJ0cnkiLCJ2YWx1ZVN0cmluZyIsIlN0cmluZyIsInZhbGlkYXRvckFyZ3MiLCJfZXh0cmFjdFZhbGlkYXRvckFyZ3MiLCJhc3NpZ24iLCJ2YWxpZGF0b3JOYW1lIiwiYXJncyIsImlzTG9jYWxpemVkVmFsaWRhdG9yIiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJhc3NvY2lhdGlvbiIsInZhbHVlcyIsImFzc29jaWF0aW9ucyIsImZpbmQiLCJmb3JlaWduS2V5IiwiZmllbGROYW1lIiwiZ2V0IiwiYXNzb2NpYXRpb25BY2Nlc3NvciIsImVyck1zZyIsIm5hbWUiLCJWYWxpZGF0aW9uRXJyb3JJdGVtIiwidHlwZSIsIlNUUklORyIsIlRFWFQiLCJDSVRFWFQiLCJpc09iamVjdCIsIkJ1ZmZlciIsImlzQnVmZmVyIiwicHJvbWlzZUluc3BlY3Rpb25zIiwicHJvbWlzZUluc3BlY3Rpb24iLCJpc1JlamVjdGVkIiwicmVqZWN0aW9uIiwiaXNCdWlsdEluIiwiaXNCdWlsdGluIiwicmF3RXJyb3IiLCJmbk5hbWUiLCJmbkFyZ3MiLCJtZXNzYWdlIiwiUkFXX0tFWV9OQU1FIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQUVBLE1BQU1BLENBQUMsR0FBR0MsT0FBTyxDQUFDLFFBQUQsQ0FBakI7O0FBQ0EsTUFBTUMsS0FBSyxHQUFHRCxPQUFPLENBQUMsU0FBRCxDQUFyQjs7QUFDQSxNQUFNRSxjQUFjLEdBQUdGLE9BQU8sQ0FBQyxVQUFELENBQTlCOztBQUNBLE1BQU1HLE9BQU8sR0FBR0gsT0FBTyxDQUFDLFdB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QVFDLE0sRUFBUTtBQUMvRCxZQUFNQyxPQUFPLEdBQUdILFFBQVEsQ0FBQ0csT0FBVCxJQUFvQkgsUUFBcEIsSUFBZ0Msa0JBQWhEO0FBQ0EsWUFBTWxGLEtBQUssR0FBRyxJQUFJakMsY0FBYyxDQUFDcUcsbUJBQW5CLENBQ1ppQixPQURZLEVBRVosa0JBRlksRUFFUTtBQUNwQjVDLE1BQUFBLFFBSFksRUFJWmpDLEtBSlksRUFLWixLQUFLbkMsYUFMTyxFQU1aOEcsTUFOWSxFQU9aRixTQUFTLEdBQUdFLE1BQUgsR0FBWXpELFNBUFQsRUFRWnVELFNBQVMsR0FBR0csTUFBSCxHQUFZMUQsU0FSVCxDQUFkO0FBV0ExQixNQUFBQSxLQUFLLENBQUM1QixpQkFBaUIsQ0FBQ2tILFlBQW5CLENBQUwsR0FBd0NKLFFBQXhDO0FBRUEsV0FBS2pHLE1BQUwsQ0FBWWdDLElBQVosQ0FBaUJqQixLQUFqQjtBQUNEOzs7OztBQUVIO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTVCLGlCQUFpQixDQUFDa0gsWUFBbEIsR0FBaUMsVUFBakM7QUFFQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCcEgsaUJBQWpCO0FBQ0FtSCxNQUFNLENBQUNDLE9BQVAsQ0FBZXBILGlCQUFmLEdBQW1DQSxpQkFBbkM7QUFDQW1ILE1BQU0sQ0FBQ0MsT0FBUCxDQUFlQyxPQUFmLEdBQXlCckgsaUJBQXpCIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4vZGF0YS10eXBlcycpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZSgnLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10bycpO1xuY29uc3QgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi91dGlscy92YWxpZGF0b3ItZXh0cmFzJykudmFsaWRhdG9yO1xuXG4vKipcbiAqIEluc3RhbmNlIFZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0luc3RhbmNlfSBtb2RlbEluc3RhbmNlIFRoZSBtb2RlbCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgZGljdGlvbmFyeSB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgSW5zdGFuY2VWYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3Rvcihtb2RlbEluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XG5cbiAgICBpZiAob3B0aW9ucy5maWVsZHMgJiYgIW9wdGlvbnMuc2tpcCkge1xuICAgICAgb3B0aW9ucy5za2lwID0gXy5kaWZmZXJlbmNlKE9iamVjdC5rZXlzKG1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcyksIG9wdGlvbnMuZmllbGRzKTtcbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gZGVmaW5lZCBhbmQgZGVmYXVsdCBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBza2lwOiBbXSxcbiAgICAgIGhvb2tzOiB0cnVlXG4gICAgfSk7XG5cbiAgICB0aGlzLm1vZGVsSW5zdGFuY2UgPSBtb2RlbEluc3RhbmNlO1xuXG4gICAgLyoqXG4gICAgICogRXhwb3NlcyBhIHJlZmVyZW5jZSB0byB2YWxpZGF0b3IuanMuIFRoaXMgYWxsb3dzIHlvdSB0byBhZGQgY3VzdG9tIHZhbGlkYXRpb25zIHVzaW5nIGB2YWxpZGF0b3IuZXh0ZW5kYFxuICAgICAqIEBuYW1lIHZhbGlkYXRvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG5cbiAgICAvKipcbiAgICAgKiAgQWxsIGVycm9ycyB3aWxsIGJlIHN0b3JlZCBoZXJlIGZyb20gdGhlIHZhbGlkYXRpb25zLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5fSBXaWxsIGNvbnRhaW4ga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gYXR0cmlidXRlcyB3aGljaCB3aWxsXG4gICAgICogICBiZSBBcnJheXMgb2YgRXJyb3JzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdmFsaWRhdGlvbnMgYXJlIGluIHByb2dyZXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgdGhlIFZhbGlkYXRpb24gbW9kdWxlLCBpbnZva2UgdG8gc3RhcnQgdGhlIGRhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF92YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5pblByb2dyZXNzKSB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb25zIGFscmVhZHkgaW4gcHJvZ3Jlc3MuJyk7XG5cbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuX3BlckF0dHJpYnV0ZVZhbGlkYXRvcnMoKS5yZWZsZWN0KCksXG4gICAgICB0aGlzLl9jdXN0b21WYWxpZGF0b3JzKCkucmVmbGVjdCgpXG4gICAgXSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3IobnVsbCwgdGhpcy5lcnJvcnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZSB0aGUgVmFsaWRhdGlvbiBzZXF1ZW5jZSBhbmQgcnVuIHZhbGlkYXRpb24gaG9va3MgaWYgZGVmaW5lZFxuICAgKiAgIC0gQmVmb3JlIFZhbGlkYXRpb24gTW9kZWwgSG9va3NcbiAgICogICAtIFZhbGlkYXRpb25cbiAgICogICAtIE9uIHZhbGlkYXRpb24gc3VjY2VzczogQWZ0ZXIgVmFsaWRhdGlvbiBNb2RlbCBIb29rc1xuICAgKiAgIC0gT24gdmFsaWRhdGlvbiBmYWlsdXJlOiBWYWxpZGF0aW9uIEZhaWxlZCBNb2RlbCBIb29rc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhbGlkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaG9va3MgPyB0aGlzLl92YWxpZGF0ZUFuZFJ1bkhvb2tzKCkgOiB0aGlzLl92YWxpZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZSB0aGUgVmFsaWRhdGlvbiBzZXF1ZW5jZSBhbmQgcnVuIGhvb2tzXG4gICAqICAgLSBCZWZvcmUgVmFsaWRhdGlvbiBNb2RlbCBIb29rc1xuICAgKiAgIC0gVmFsaWRhdGlvblxuICAgKiAgIC0gT24gdmFsaWRhdGlvbiBzdWNjZXNzOiBBZnRlciBWYWxpZGF0aW9uIE1vZGVsIEhvb2tzXG4gICAqICAgLSBPbiB2YWxpZGF0aW9uIGZhaWx1cmU6IFZhbGlkYXRpb24gRmFpbGVkIE1vZGVsIEhvb2tzXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ZhbGlkYXRlQW5kUnVuSG9va3MoKSB7XG4gICAgY29uc3QgcnVuSG9va3MgPSB0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IucnVuSG9va3MuYmluZCh0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IpO1xuICAgIHJldHVybiBydW5Ib29rcygnYmVmb3JlVmFsaWRhdGUnLCB0aGlzLm1vZGVsSW5zdGFuY2UsIHRoaXMub3B0aW9ucylcbiAgICAgIC50aGVuKCgpID0+XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKClcbiAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gcnVuSG9va3MoJ3ZhbGlkYXRpb25GYWlsZWQnLCB0aGlzLm1vZGVsSW5zdGFuY2UsIHRoaXMub3B0aW9ucywgZXJyb3IpXG4gICAgICAgICAgICAudGhlbihuZXdFcnJvciA9PiB7IHRocm93IG5ld0Vycm9yIHx8IGVycm9yOyB9KSlcbiAgICAgIClcbiAgICAgIC50aGVuKCgpID0+IHJ1bkhvb2tzKCdhZnRlclZhbGlkYXRlJywgdGhpcy5tb2RlbEluc3RhbmNlLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLnJldHVybih0aGlzLm1vZGVsSW5zdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcnVuIGFsbCB0aGUgdmFsaWRhdG9ycyBkZWZpbmVkIHBlciBhdHRyaWJ1dGUgKGJ1aWx0LWluIHZhbGlkYXRvcnMgYW5kIGN1c3RvbSB2YWxpZGF0b3JzKVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheS48UHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbj4+fSBBIHByb21pc2UgZnJvbSAucmVmbGVjdCgpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlckF0dHJpYnV0ZVZhbGlkYXRvcnMoKSB7XG4gICAgLy8gcHJvbWlzaWZ5IGFsbCBhdHRyaWJ1dGUgaW52b2NhdGlvbnNcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG5cbiAgICBfLmZvckluKHRoaXMubW9kZWxJbnN0YW5jZS5yYXdBdHRyaWJ1dGVzLCAocmF3QXR0cmlidXRlLCBmaWVsZCkgPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tb2RlbEluc3RhbmNlLmRhdGFWYWx1ZXNbZmllbGRdO1xuXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJhd0F0dHJpYnV0ZS5fYXV0b0dlbmVyYXRlZCAmJiAhcmF3QXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgLy8gcGVyZm9ybSB2YWxpZGF0aW9ucyBiYXNlZCBvbiBzY2hlbWFcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVTY2hlbWEocmF3QXR0cmlidXRlLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubW9kZWxJbnN0YW5jZS52YWxpZGF0b3JzLCBmaWVsZCkpIHtcbiAgICAgICAgdmFsaWRhdG9ycy5wdXNoKHRoaXMuX3NpbmdsZUF0dHJWYWxpZGF0ZSh2YWx1ZSwgZmllbGQsIHJhd0F0dHJpYnV0ZS5hbGxvd051bGwpLnJlZmxlY3QoKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsaWRhdG9ycyk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBydW4gYWxsIHRoZSBjdXN0b20gdmFsaWRhdG9ycyBkZWZpbmVkIGluIHRoZSBtb2RlbCdzIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5LjxQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uPj59IEEgcHJvbWlzZSBmcm9tIC5yZWZsZWN0KCkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3VzdG9tVmFsaWRhdG9ycygpIHtcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG4gICAgXy5lYWNoKHRoaXMubW9kZWxJbnN0YW5jZS5fbW9kZWxPcHRpb25zLnZhbGlkYXRlLCAodmFsaWRhdG9yLCB2YWxpZGF0b3JUeXBlKSA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNraXAuaW5jbHVkZXModmFsaWRhdG9yVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWxwcm9tID0gdGhpcy5faW52b2tlQ3VzdG9tVmFsaWRhdG9yKHZhbGlkYXRvciwgdmFsaWRhdG9yVHlwZSlcbiAgICAgICAgLy8gZXJyb3JzIGFyZSBoYW5kbGVkIGluIHNldHRsaW5nLCBzdHViIHRoaXNcbiAgICAgICAgLmNhdGNoKCgpID0+IHt9KVxuICAgICAgICAucmVmbGVjdCgpO1xuXG4gICAgICB2YWxpZGF0b3JzLnB1c2godmFscHJvbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsaWRhdG9ycyk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYSBzaW5nbGUgYXR0cmlidXRlIHdpdGggYWxsIHRoZSBkZWZpbmVkIGJ1aWx0LWluIHZhbGlkYXRvcnMgYW5kIGN1c3RvbSB2YWxpZGF0b3JzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueXRoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dOdWxsIFdoZXRoZXIgb3Igbm90IHRoZSBzY2hlbWEgYWxsb3dzIG51bGwgdmFsdWVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UsIHdpbGwgYWx3YXlzIHJlc29sdmUsIGF1dG8gcG9wdWxhdGVzIGVycm9yIG9uIHRoaXMuZXJyb3IgbG9jYWwgb2JqZWN0LlxuICAgKi9cbiAgX3NpbmdsZUF0dHJWYWxpZGF0ZSh2YWx1ZSwgZmllbGQsIGFsbG93TnVsbCkge1xuICAgIC8vIElmIHZhbHVlIGlzIG51bGwgYW5kIGFsbG93TnVsbCBpcyBmYWxzZSwgbm8gdmFsaWRhdG9ycyBzaG91bGQgcnVuIChzZWUgIzkxNDMpXG4gICAgaWYgKCh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSAmJiAhYWxsb3dOdWxsKSB7XG4gICAgICAvLyBUaGUgc2NoZW1hIHZhbGlkYXRvciAoX3ZhbGlkYXRlU2NoZW1hKSBoYXMgYWxyZWFkeSBnZW5lcmF0ZWQgdGhlIHZhbGlkYXRpb24gZXJyb3IuIE5vdGhpbmcgdG8gZG8gaGVyZS5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICAvLyBQcm9taXNpZnkgZWFjaCB2YWxpZGF0b3JcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG4gICAgXy5mb3JJbih0aGlzLm1vZGVsSW5zdGFuY2UudmFsaWRhdG9yc1tmaWVsZF0sICh0ZXN0LCB2YWxpZGF0b3JUeXBlKSA9PiB7XG5cbiAgICAgIGlmICh2YWxpZGF0b3JUeXBlID09PSAnaXNVcmwnIHx8IHZhbGlkYXRvclR5cGUgPT09ICdpc1VSTCcgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzRW1haWwnKSB7XG4gICAgICAgIC8vIFByZXNlcnZlIGJhY2t3YXJkcyBjb21wYXQuIFZhbGlkYXRvci5qcyBub3cgZXhwZWN0cyB0aGUgc2Vjb25kIHBhcmFtIHRvIGlzVVJMIGFuZCBpc0VtYWlsIHRvIGJlIGFuIG9iamVjdFxuICAgICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdvYmplY3QnICYmIHRlc3QgIT09IG51bGwgJiYgdGVzdC5tc2cpIHtcbiAgICAgICAgICB0ZXN0ID0ge1xuICAgICAgICAgICAgbXNnOiB0ZXN0Lm1zZ1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGVzdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRlc3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDdXN0b20gdmFsaWRhdG9ycyBzaG91bGQgYWx3YXlzIHJ1biwgZXhjZXB0IGlmIHZhbHVlIGlzIG51bGwgYW5kIGFsbG93TnVsbCBpcyBmYWxzZSAoc2VlICM5MTQzKVxuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRvcnMucHVzaCh0aGlzLl9pbnZva2VDdXN0b21WYWxpZGF0b3IodGVzdCwgdmFsaWRhdG9yVHlwZSwgdHJ1ZSwgdmFsdWUsIGZpZWxkKS5yZWZsZWN0KCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHZhbHVlIGlzIG51bGwsIGJ1aWx0LWluIHZhbGlkYXRvcnMgc2hvdWxkIG5vdCBydW4gKG9ubHkgY3VzdG9tIHZhbGlkYXRvcnMgaGF2ZSB0byBydW4pIChzZWUgIzkxMzQpLlxuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWxpZGF0b3JQcm9taXNlID0gdGhpcy5faW52b2tlQnVpbHRpblZhbGlkYXRvcih2YWx1ZSwgdGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpO1xuICAgICAgLy8gZXJyb3JzIGFyZSBoYW5kbGVkIGluIHNldHRsaW5nLCBzdHViIHRoaXNcbiAgICAgIHZhbGlkYXRvclByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuICAgICAgdmFsaWRhdG9ycy5wdXNoKHZhbGlkYXRvclByb21pc2UucmVmbGVjdCgpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBQcm9taXNlXG4gICAgICAuYWxsKHZhbGlkYXRvcnMpXG4gICAgICAudGhlbihyZXN1bHRzID0+IHRoaXMuX2hhbmRsZVJlZmxlY3RlZFJlc3VsdChmaWVsZCwgdmFsdWUsIHJlc3VsdHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGFuZCBpbnZva2UgYSBjdXN0b20gdmFsaWRhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB2YWxpZGF0b3IgVGhlIGN1c3RvbSB2YWxpZGF0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JUeXBlIHRoZSBjdXN0b20gdmFsaWRhdG9yIHR5cGUgKG5hbWUpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdEF0dHJEZWZpbmVkIFNldCB0byB0cnVlIGlmIGN1c3RvbSB2YWxpZGF0b3Igd2FzIGRlZmluZWQgZnJvbSB0aGUgYXR0cmlidXRlXG4gICAqIEBwYXJhbSB7Kn0gb3B0VmFsdWUgdmFsdWUgZm9yIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0RmllbGQgZmllbGQgZm9yIGF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlLlxuICAgKi9cbiAgX2ludm9rZUN1c3RvbVZhbGlkYXRvcih2YWxpZGF0b3IsIHZhbGlkYXRvclR5cGUsIG9wdEF0dHJEZWZpbmVkLCBvcHRWYWx1ZSwgb3B0RmllbGQpIHtcbiAgICBsZXQgdmFsaWRhdG9yRnVuY3Rpb24gPSBudWxsOyAvLyB0aGUgdmFsaWRhdGlvbiBmdW5jdGlvbiB0byBjYWxsXG4gICAgbGV0IGlzQXN5bmMgPSBmYWxzZTtcblxuICAgIGNvbnN0IHZhbGlkYXRvckFyaXR5ID0gdmFsaWRhdG9yLmxlbmd0aDtcbiAgICAvLyBjaGVjayBpZiB2YWxpZGF0b3IgaXMgYXN5bmMgYW5kIHJlcXVpcmVzIGEgY2FsbGJhY2tcbiAgICBsZXQgYXN5bmNBcml0eSA9IDE7XG4gICAgbGV0IGVycm9yS2V5ID0gdmFsaWRhdG9yVHlwZTtcbiAgICBsZXQgaW52b2tlQXJncztcbiAgICBpZiAob3B0QXR0ckRlZmluZWQpIHtcbiAgICAgIGFzeW5jQXJpdHkgPSAyO1xuICAgICAgaW52b2tlQXJncyA9IG9wdFZhbHVlO1xuICAgICAgZXJyb3JLZXkgPSBvcHRGaWVsZDtcbiAgICB9XG4gICAgaWYgKHZhbGlkYXRvckFyaXR5ID09PSBhc3luY0FyaXR5KSB7XG4gICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBc3luYykge1xuICAgICAgaWYgKG9wdEF0dHJEZWZpbmVkKSB7XG4gICAgICAgIHZhbGlkYXRvckZ1bmN0aW9uID0gUHJvbWlzZS5wcm9taXNpZnkodmFsaWRhdG9yLmJpbmQodGhpcy5tb2RlbEluc3RhbmNlLCBpbnZva2VBcmdzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3JGdW5jdGlvbiA9IFByb21pc2UucHJvbWlzaWZ5KHZhbGlkYXRvci5iaW5kKHRoaXMubW9kZWxJbnN0YW5jZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkYXRvckZ1bmN0aW9uKClcbiAgICAgICAgLmNhdGNoKGUgPT4gdGhpcy5fcHVzaEVycm9yKGZhbHNlLCBlcnJvcktleSwgZSwgb3B0VmFsdWUsIHZhbGlkYXRvclR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2VcbiAgICAgIC50cnkoKCkgPT4gdmFsaWRhdG9yLmNhbGwodGhpcy5tb2RlbEluc3RhbmNlLCBpbnZva2VBcmdzKSlcbiAgICAgIC5jYXRjaChlID0+IHRoaXMuX3B1c2hFcnJvcihmYWxzZSwgZXJyb3JLZXksIGUsIG9wdFZhbHVlLCB2YWxpZGF0b3JUeXBlKSk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBhbmQgaW52b2tlIGEgYnVpbGQtaW4gdmFsaWRhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueXRoaW5nLlxuICAgKiBAcGFyYW0geyp9IHRlc3QgVGhlIHRlc3QgY2FzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvclR5cGUgT25lIG9mIGtub3duIHRvIFNlcXVlbGl6ZSB2YWxpZGF0b3JzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgaXMgYmVpbmcgdmFsaWRhdGVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHNwZWNpZmljIGtleXMgdG8gaW52b2tlIHRoZSB2YWxpZGF0b3IuXG4gICAqL1xuICBfaW52b2tlQnVpbHRpblZhbGlkYXRvcih2YWx1ZSwgdGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS50cnkoKCkgPT4ge1xuICAgICAgLy8gQ2FzdCB2YWx1ZSBhcyBzdHJpbmcgdG8gcGFzcyBuZXcgVmFsaWRhdG9yLmpzIHN0cmluZyByZXF1aXJlbWVudFxuICAgICAgY29uc3QgdmFsdWVTdHJpbmcgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgLy8gY2hlY2sgaWYgVmFsaWRhdG9yIGtub3dzIHRoYXQga2luZCBvZiB2YWxpZGF0aW9uIHRlc3RcbiAgICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yW3ZhbGlkYXRvclR5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgZnVuY3Rpb246ICR7dmFsaWRhdG9yVHlwZX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsaWRhdG9yQXJncyA9IHRoaXMuX2V4dHJhY3RWYWxpZGF0b3JBcmdzKHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKTtcblxuICAgICAgaWYgKCF2YWxpZGF0b3JbdmFsaWRhdG9yVHlwZV0odmFsdWVTdHJpbmcsIC4uLnZhbGlkYXRvckFyZ3MpKSB7XG4gICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKHRlc3QubXNnIHx8IGBWYWxpZGF0aW9uICR7dmFsaWRhdG9yVHlwZX0gb24gJHtmaWVsZH0gZmFpbGVkYCksIHsgdmFsaWRhdG9yTmFtZTogdmFsaWRhdG9yVHlwZSwgdmFsaWRhdG9yQXJncyB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIGV4dHJhY3QgYXJndW1lbnRzIGZvciB0aGUgdmFsaWRhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHRlc3QgVGhlIHRlc3QgY2FzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvclR5cGUgT25lIG9mIGtub3duIHRvIFNlcXVlbGl6ZSB2YWxpZGF0b3JzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgaXMgYmVpbmcgdmFsaWRhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V4dHJhY3RWYWxpZGF0b3JBcmdzKHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKSB7XG4gICAgbGV0IHZhbGlkYXRvckFyZ3MgPSB0ZXN0LmFyZ3MgfHwgdGVzdDtcbiAgICBjb25zdCBpc0xvY2FsaXplZFZhbGlkYXRvciA9IHR5cGVvZiB2YWxpZGF0b3JBcmdzICE9PSAnc3RyaW5nJyAmJiAodmFsaWRhdG9yVHlwZSA9PT0gJ2lzQWxwaGEnIHx8IHZhbGlkYXRvclR5cGUgPT09ICdpc0FscGhhbnVtZXJpYycgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzTW9iaWxlUGhvbmUnKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JBcmdzKSkge1xuICAgICAgaWYgKHZhbGlkYXRvclR5cGUgPT09ICdpc0ltbXV0YWJsZScpIHtcbiAgICAgICAgdmFsaWRhdG9yQXJncyA9IFt2YWxpZGF0b3JBcmdzLCBmaWVsZCwgdGhpcy5tb2RlbEluc3RhbmNlXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMb2NhbGl6ZWRWYWxpZGF0b3IgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzSVAnKSB7XG4gICAgICAgIHZhbGlkYXRvckFyZ3MgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRvckFyZ3MgPSBbdmFsaWRhdG9yQXJnc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRvckFyZ3MgPSB2YWxpZGF0b3JBcmdzLnNsaWNlKDApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdG9yQXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHZhbGlkYXRlIGEgc2luZ2xlIGZpZWxkIGFnYWluc3QgaXRzIHNjaGVtYSBkZWZpbml0aW9uIChpc251bGwpLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmF3QXR0cmlidXRlIEFzIGRlZmluZWQgaW4gdGhlIFNjaGVtYS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIGFueXRoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ZhbGlkYXRlU2NoZW1hKHJhd0F0dHJpYnV0ZSwgZmllbGQsIHZhbHVlKSB7XG4gICAgaWYgKHJhd0F0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgY29uc3QgYXNzb2NpYXRpb24gPSBfLnZhbHVlcyh0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IuYXNzb2NpYXRpb25zKS5maW5kKGFzc29jaWF0aW9uID0+IGFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvICYmIGFzc29jaWF0aW9uLmZvcmVpZ25LZXkgPT09IHJhd0F0dHJpYnV0ZS5maWVsZE5hbWUpO1xuICAgICAgaWYgKCFhc3NvY2lhdGlvbiB8fCAhdGhpcy5tb2RlbEluc3RhbmNlLmdldChhc3NvY2lhdGlvbi5hc3NvY2lhdGlvbkFjY2Vzc29yKSkge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0gdGhpcy5tb2RlbEluc3RhbmNlLnZhbGlkYXRvcnNbZmllbGRdO1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBfLmdldCh2YWxpZGF0b3JzLCAnbm90TnVsbC5tc2cnLCBgJHt0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IubmFtZX0uJHtmaWVsZH0gY2Fubm90IGJlIG51bGxgKTtcblxuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgICAgIGVyck1zZyxcbiAgICAgICAgICAnbm90TnVsbCBWaW9sYXRpb24nLCAvLyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMuQ09SRSxcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB0aGlzLm1vZGVsSW5zdGFuY2UsXG4gICAgICAgICAgJ2lzX251bGwnXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5TVFJJTkcgfHwgcmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVEVYVCB8fCByYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5DSVRFWFQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBfLmlzT2JqZWN0KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSAmJiAhQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgICAgIGAke2ZpZWxkfSBjYW5ub3QgYmUgYW4gYXJyYXkgb3IgYW4gb2JqZWN0YCxcbiAgICAgICAgICAnc3RyaW5nIHZpb2xhdGlvbicsIC8vIHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5DT1JFLFxuICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHRoaXMubW9kZWxJbnN0YW5jZSxcbiAgICAgICAgICAnbm90X2Ffc3RyaW5nJ1xuICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSByZXR1cm5lZCByZXN1bHQgb2YgYSBQcm9taXNlLnJlZmxlY3QuXG4gICAqXG4gICAqIElmIGVycm9ycyBhcmUgZm91bmQgaXQgcG9wdWxhdGVzIHRoaXMuZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYXR0cmlidXRlIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgVGhlIGRhdGEgdmFsdWUuXG4gICAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbj59IHByb21pc2VJbnNwZWN0aW9ucyBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZVJlZmxlY3RlZFJlc3VsdChmaWVsZCwgdmFsdWUsIHByb21pc2VJbnNwZWN0aW9ucykge1xuICAgIGZvciAoY29uc3QgcHJvbWlzZUluc3BlY3Rpb24gb2YgcHJvbWlzZUluc3BlY3Rpb25zKSB7XG4gICAgICBpZiAocHJvbWlzZUluc3BlY3Rpb24uaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIGNvbnN0IHJlamVjdGlvbiA9IHByb21pc2VJbnNwZWN0aW9uLmVycm9yKCk7XG4gICAgICAgIGNvbnN0IGlzQnVpbHRJbiA9ICEhcmVqZWN0aW9uLnZhbGlkYXRvck5hbWU7XG5cbiAgICAgICAgdGhpcy5fcHVzaEVycm9yKGlzQnVpbHRJbiwgZmllbGQsIHJlamVjdGlvbiwgdmFsdWUsIHJlamVjdGlvbi52YWxpZGF0b3JOYW1lLCByZWplY3Rpb24udmFsaWRhdG9yQXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIGFsbCBlcnJvcnMgcmV0YWluaW5nIHRoZSBvcmlnaW5hbC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICBpc0J1aWx0aW4gICAtIERldGVybWluZXMgaWYgZXJyb3IgaXMgZnJvbSBidWlsdGluIHZhbGlkYXRvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICBlcnJvcktleSAgICAtIG5hbWUgb2YgaW52YWxpZCBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7RXJyb3J8c3RyaW5nfSAgcmF3RXJyb3IgICAgLSBUaGUgb3JpZ2luYWwgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgICAgICAgLSBUaGUgZGF0YSB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgZm5OYW1lICAgICAgLSBOYW1lIG9mIHRoZSB2YWxpZGF0b3IsIGlmIGFueVxuICAgKiBAcGFyYW0ge0FycmF5fSAgICAgICAgIGZuQXJncyAgICAgIC0gQXJndW1lbnRzIGZvciB0aGUgdmFsaWRhdG9yIFtmdW5jdGlvbl0sIGlmIGFueVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3B1c2hFcnJvcihpc0J1aWx0aW4sIGVycm9yS2V5LCByYXdFcnJvciwgdmFsdWUsIGZuTmFtZSwgZm5BcmdzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHJhd0Vycm9yLm1lc3NhZ2UgfHwgcmF3RXJyb3IgfHwgJ1ZhbGlkYXRpb24gZXJyb3InO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0oXG4gICAgICBtZXNzYWdlLFxuICAgICAgJ1ZhbGlkYXRpb24gZXJyb3InLCAvLyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMuRlVOQ1RJT04sXG4gICAgICBlcnJvcktleSxcbiAgICAgIHZhbHVlLFxuICAgICAgdGhpcy5tb2RlbEluc3RhbmNlLFxuICAgICAgZm5OYW1lLFxuICAgICAgaXNCdWlsdGluID8gZm5OYW1lIDogdW5kZWZpbmVkLFxuICAgICAgaXNCdWlsdGluID8gZm5BcmdzIDogdW5kZWZpbmVkXG4gICAgKTtcblxuICAgIGVycm9yW0luc3RhbmNlVmFsaWRhdG9yLlJBV19LRVlfTkFNRV0gPSByYXdFcnJvcjtcblxuICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG59XG4vKipcbiAqIEBkZWZpbmUge3N0cmluZ30gVGhlIGVycm9yIGtleSBmb3IgYXJndW1lbnRzIGFzIHBhc3NlZCBieSBjdXN0b20gdmFsaWRhdG9yc1xuICogQHByaXZhdGVcbiAqL1xuSW5zdGFuY2VWYWxpZGF0b3IuUkFXX0tFWV9OQU1FID0gJ29yaWdpbmFsJztcblxubW9kdWxlLmV4cG9ydHMgPSBJbnN0YW5jZVZhbGlkYXRvcjtcbm1vZHVsZS5leHBvcnRzLkluc3RhbmNlVmFsaWRhdG9yID0gSW5zdGFuY2VWYWxpZGF0b3I7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gSW5zdGFuY2VWYWxpZGF0b3I7XG4iXX0=