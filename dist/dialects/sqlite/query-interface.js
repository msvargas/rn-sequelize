'use strict';

const _ = require('lodash');

const Promise = require('../../promise');

const sequelizeErrors = require('../../errors');

const QueryTypes = require('../../query-types');
/**
 Returns an object that treats SQLite's inabilities to do certain queries.

 @class QueryInterface
 @static
 @private
 */

/**
  A wrapper that fixes SQLite's inability to remove columns from existing tables.
  It will create a backup of the table, drop the table afterwards and create a
  new table with the same name but without the obsolete column.

  @param  {QueryInterface} qi
  @param  {string} tableName     The name of the table.
  @param  {string} attributeName The name of the attribute that we want to remove.
  @param  {Object} options
  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries

  @since 1.6.0
  @private
 */


function removeColumn(qi, tableName, attributeName, options) {
  options = options || {};
  return qi.describeTable(tableName, options).then(fields => {
    delete fields[attributeName];
    const sql = qi.QueryGenerator.removeColumnQuery(tableName, fields);
    const subQueries = sql.split(';').filter(q => q !== '');
    return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({
      raw: true
    }, options)));
  });
}

exports.removeColumn = removeColumn;
/**
  A wrapper that fixes SQLite's inability to change columns from existing tables.
  It will create a backup of the table, drop the table afterwards and create a
  new table with the same name but with a modified version of the respective column.

  @param  {QueryInterface} qi
  @param  {string} tableName The name of the table.
  @param  {Object} attributes An object with the attribute's name as key and its options as value object.
  @param  {Object} options
  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries

  @since 1.6.0
  @private
 */

function changeColumn(qi, tableName, attributes, options) {
  const attributeName = Object.keys(attributes)[0];
  options = options || {};
  return qi.describeTable(tableName, options).then(fields => {
    fields[attributeName] = attributes[attributeName];
    const sql = qi.QueryGenerator.removeColumnQuery(tableName, fields);
    const subQueries = sql.split(';').filter(q => q !== '');
    return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({
      raw: true
    }, options)));
  });
}

exports.changeColumn = changeColumn;
/**
  A wrapper that fixes SQLite's inability to rename columns from existing tables.
  It will create a backup of the table, drop the table afterwards and create a
  new table with the same name but with a renamed version of the respective column.

  @param  {QueryInterface} qi
  @param  {string} tableName The name of the table.
  @param  {string} attrNameBefore The name of the attribute before it was renamed.
  @param  {string} attrNameAfter The name of the attribute after it was renamed.
  @param  {Object} options
  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries

  @since 1.6.0
  @private
 */

function renameColumn(qi, tableName, attrNameBefore, attrNameAfter, options) {
  options = options || {};
  return qi.describeTable(tableName, options).then(fields => {
    fields[attrNameAfter] = _.clone(fields[attrNameBefore]);
    delete fields[attrNameBefore];
    const sql = qi.QueryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);
    const subQueries = sql.split(';').filter(q => q !== '');
    return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({
      raw: true
    }, options)));
  });
}

exports.renameColumn = renameColumn;
/**
 * @param {QueryInterface} qi
 * @param {string} tableName
 * @param {string} constraintName
 * @param {Object} options
 *
 * @private
 */

function removeConstraint(qi, tableName, constraintName, options) {
  let createTableSql;
  return qi.showConstraint(tableName, constraintName).then(constraints => {
    // sqlite can't show only one constraint, so we find here the one to remove
    const constraint = constraints.find(constaint => constaint.constraintName === constraintName);

    if (constraint) {
      createTableSql = constraint.sql;
      constraint.constraintName = qi.QueryGenerator.quoteIdentifier(constraint.constraintName);
      let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;

      if (constraint.constraintType === 'FOREIGN KEY') {
        const referenceTableName = qi.QueryGenerator.quoteTable(constraint.referenceTableName);
        constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => qi.QueryGenerator.quoteIdentifier(columnName));
        const referenceTableKeys = constraint.referenceTableKeys.join(', ');
        constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;
        constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;
        constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;
      }

      createTableSql = createTableSql.replace(constraintSnippet, '');
      createTableSql += ';';
      return qi.describeTable(tableName, options);
    }

    throw new sequelizeErrors.UnknownConstraintError({
      message: `Constraint ${constraintName} on table ${tableName} does not exist`,
      constraint: constraintName,
      table: tableName
    });
  }).then(fields => {
    const sql = qi.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);

    const subQueries = sql.split(';').filter(q => q !== '');
    return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({
      raw: true
    }, options)));
  });
}

exports.removeConstraint = removeConstraint;
/**
 * @param {QueryInterface} qi
 * @param {string} tableName
 * @param {Object} options
 *
 * @private
 */

function addConstraint(qi, tableName, options) {
  const constraintSnippet = qi.QueryGenerator.getConstraintSnippet(tableName, options);
  const describeCreateTableSql = qi.QueryGenerator.describeCreateTableQuery(tableName);
  let createTableSql;
  return qi.sequelize.query(describeCreateTableSql, Object.assign({}, options, {
    type: QueryTypes.SELECT,
    raw: true
  })).then(constraints => {
    const sql = constraints[0].sql;
    const index = sql.length - 1; //Replace ending ')' with constraint snippet - Simulates String.replaceAt
    //http://stackoverflow.com/questions/1431094

    createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;
    return qi.describeTable(tableName, options);
  }).then(fields => {
    const sql = qi.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);

    const subQueries = sql.split(';').filter(q => q !== '');
    return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({
      raw: true
    }, options)));
  });
}

exports.addConstraint = addConstraint;
/**
 * @param {QueryInterface} qi
 * @param {string} tableName
 * @param {Object} options  Query Options
 *
 * @private
 * @returns {Promise}
 */

function getForeignKeyReferencesForTable(qi, tableName, options) {
  const database = qi.sequelize.config.database;
  const query = qi.QueryGenerator.getForeignKeysQuery(tableName, database);
  return qi.sequelize.query(query, options).then(result => {
    return result.map(row => ({
      tableName,
      columnName: row.from,
      referencedTableName: row.table,
      referencedColumnName: row.to,
      tableCatalog: database,
      referencedTableCatalog: database
    }));
  });
}

exports.getForeignKeyReferencesForTable = getForeignKeyReferencesForTable;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktaW50ZXJmYWNlLmpzIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiUHJvbWlzZSIsInNlcXVlbGl6ZUVycm9ycyIsIlF1ZXJ5VHlwZXMiLCJyZW1vdmVDb2x1bW4iLCJxaSIsInRhYmxlTmFtZSIsImF0dHJpYnV0ZU5hbWUiLCJvcHRpb25zIiwiZGVzY3JpYmVUYWJsZSIsInRoZW4iLCJmaWVsZHMiLCJzcWwiLCJRdWVyeUdlbmVyYXRvciIsInJlbW92ZUNvbHVtblF1ZXJ5Iiwic3ViUXVlcmllcyIsInNwbGl0IiwiZmlsdGVyIiwicSIsImVhY2giLCJzdWJRdWVyeSIsInNlcXVlbGl6ZSIsInF1ZXJ5IiwiT2JqZWN0IiwiYXNzaWduIiwicmF3IiwiZXhwb3J0cyIsImNoYW5nZUNvbHVtbiIsImF0dHJpYnV0ZXMiLCJrZXlzIiwicmVuYW1lQ29sdW1uIiwiYXR0ck5hbWVCZWZvcmUiLCJhdHRyTmFtZUFmdGVyIiwiY2xvbmUiLCJyZW5hbWVDb2x1bW5RdWVyeSIsInJlbW92ZUNvbnN0cmFpbnQiLCJjb25zdHJhaW50TmFtZSIsImNyZWF0ZVRhYmxlU3FsIiwic2hvd0NvbnN0cmFpbnQiLCJjb25zdHJhaW50cyIsImNvbnN0cmFpbnQiLCJmaW5kIiwiY29uc3RhaW50IiwicXVvdGVJZGVudGlmaWVyIiwiY29uc3RyYWludFNuaXBwZXQiLCJjb25zdHJhaW50VHlwZSIsImNvbnN0cmFpbnRDb25kaXRpb24iLCJyZWZlcmVuY2VUYWJsZU5hbWUiLCJxdW90ZVRhYmxlIiwicmVmZXJlbmNlVGFibGVLZXlzIiwibWFwIiwiY29sdW1uTmFtZSIsImpvaW4iLCJ1cGRhdGVBY3Rpb24iLCJkZWxldGVBY3Rpb24iLCJyZXBsYWNlIiwiVW5rbm93bkNvbnN0cmFpbnRFcnJvciIsIm1lc3NhZ2UiLCJ0YWJsZSIsIl9hbHRlckNvbnN0cmFpbnRRdWVyeSIsImFkZENvbnN0cmFpbnQiLCJnZXRDb25zdHJhaW50U25pcHBldCIsImRlc2NyaWJlQ3JlYXRlVGFibGVTcWwiLCJkZXNjcmliZUNyZWF0ZVRhYmxlUXVlcnkiLCJ0eXBlIiwiU0VMRUNUIiwiaW5kZXgiLCJsZW5ndGgiLCJzdWJzdHIiLCJnZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlIiwiZGF0YWJhc2UiLCJjb25maWciLCJnZXRGb3JlaWduS2V5c1F1ZXJ5IiwicmVzdWx0Iiwicm93IiwiZnJvbSIsInJlZmVyZW5jZWRUYWJsZU5hbWUiLCJyZWZlcmVuY2VkQ29sdW1uTmFtZSIsInRvIiwidGFibGVDYXRhbG9nIiwicmVmZXJlbmNlZFRhYmxlQ2F0YWxvZyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsTUFBTUEsQ0FBQyxHQUFHQyxPQUFPLENBQUMsUUFBRCxDQUFqQjs7QUFDQSxNQUFNQyxPQUFPLEdBQUdELE9BQU8sQ0FBQyxlQUFELENBQXZCOztBQUNBLE1BQU1FLGVBQWUsR0FBR0YsT0FBTyxDQUFDLGNBQUQsQ0FBL0I7O0FBQ0EsTUFBTUcsVUFBVSxHQUFHSCxPQUFPLENBQUMsbUJBQUQsQ0FBMUI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTSSxZQUFULENBQXNCQyxFQUF0QixFQUEwQkMsU0FBMUIsRUFBcUNDLGFBQXJDLEVBQW9EQyxPQUFwRCxFQUE2RDtBQUMzREEsRUFBQUEsT0FBTyxHQUFHQSxPQUFPLElBQUksRUFBckI7QUFFQSxTQUFPSCxFQUFFLENBQUNJLGFBQUgsQ0FBaUJILFNBQWpCLEVBQTRCRSxPQUE1QixFQUFxQ0UsSUFBckMsQ0FBMENDLE1BQU0sSUFBSTtBQUN6RCxXQUFPQSxNQUFNLENBQUNKLGFBQUQsQ0FBYjtBQUVBLFVBQU1LLEdBQUcsR0FBR1AsRUFBRSxDQUFDUSxjQUFILENBQWtCQyxpQkFBbEIsQ0FBb0NSLFNBQXBDLEVBQStDSyxNQUEv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QUNBLFNBQVNTLCtCQUFULENBQXlDaEUsRUFBekMsRUFBNkNDLFNBQTdDLEVBQXdERSxPQUF4RCxFQUFpRTtBQUMvRCxRQUFNOEQsUUFBUSxHQUFHakUsRUFBRSxDQUFDZ0IsU0FBSCxDQUFha0QsTUFBYixDQUFvQkQsUUFBckM7QUFDQSxRQUFNaEQsS0FBSyxHQUFHakIsRUFBRSxDQUFDUSxjQUFILENBQWtCMkQsbUJBQWxCLENBQXNDbEUsU0FBdEMsRUFBaURnRSxRQUFqRCxDQUFkO0FBQ0EsU0FBT2pFLEVBQUUsQ0FBQ2dCLFNBQUgsQ0FBYUMsS0FBYixDQUFtQkEsS0FBbkIsRUFBMEJkLE9BQTFCLEVBQ0pFLElBREksQ0FDQytELE1BQU0sSUFBSTtBQUNkLFdBQU9BLE1BQU0sQ0FBQ3ZCLEdBQVAsQ0FBV3dCLEdBQUcsS0FBSztBQUN4QnBFLE1BQUFBLFNBRHdCO0FBRXhCNkMsTUFBQUEsVUFBVSxFQUFFdUIsR0FBRyxDQUFDQyxJQUZRO0FBR3hCQyxNQUFBQSxtQkFBbUIsRUFBRUYsR0FBRyxDQUFDaEIsS0FIRDtBQUl4Qm1CLE1BQUFBLG9CQUFvQixFQUFFSCxHQUFHLENBQUNJLEVBSkY7QUFLeEJDLE1BQUFBLFlBQVksRUFBRVQsUUFMVTtBQU14QlUsTUFBQUEsc0JBQXNCLEVBQUVWO0FBTkEsS0FBTCxDQUFkLENBQVA7QUFRRCxHQVZJLENBQVA7QUFXRDs7QUFFRDVDLE9BQU8sQ0FBQzJDLCtCQUFSLEdBQTBDQSwrQkFBMUMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IFByb21pc2UgPSByZXF1aXJlKCcuLi8uLi9wcm9taXNlJyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuLi8uLi9xdWVyeS10eXBlcycpO1xuXG4vKipcbiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IHRyZWF0cyBTUUxpdGUncyBpbmFiaWxpdGllcyB0byBkbyBjZXJ0YWluIHF1ZXJpZXMuXG5cbiBAY2xhc3MgUXVlcnlJbnRlcmZhY2VcbiBAc3RhdGljXG4gQHByaXZhdGVcbiAqL1xuXG4vKipcbiAgQSB3cmFwcGVyIHRoYXQgZml4ZXMgU1FMaXRlJ3MgaW5hYmlsaXR5IHRvIHJlbW92ZSBjb2x1bW5zIGZyb20gZXhpc3RpbmcgdGFibGVzLlxuICBJdCB3aWxsIGNyZWF0ZSBhIGJhY2t1cCBvZiB0aGUgdGFibGUsIGRyb3AgdGhlIHRhYmxlIGFmdGVyd2FyZHMgYW5kIGNyZWF0ZSBhXG4gIG5ldyB0YWJsZSB3aXRoIHRoZSBzYW1lIG5hbWUgYnV0IHdpdGhvdXQgdGhlIG9ic29sZXRlIGNvbHVtbi5cblxuICBAcGFyYW0gIHtRdWVyeUludGVyZmFjZX0gcWlcbiAgQHBhcmFtICB7c3RyaW5nfSB0YWJsZU5hbWUgICAgIFRoZSBuYW1lIG9mIHRoZSB0YWJsZS5cbiAgQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdGhhdCB3ZSB3YW50IHRvIHJlbW92ZS5cbiAgQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gIEBwYXJhbSAge2Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmddIEEgZnVuY3Rpb24gdGhhdCBsb2dzIHRoZSBzcWwgcXVlcmllcywgb3IgZmFsc2UgZm9yIGV4cGxpY2l0bHkgbm90IGxvZ2dpbmcgdGhlc2UgcXVlcmllc1xuXG4gIEBzaW5jZSAxLjYuMFxuICBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVDb2x1bW4ocWksIHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICByZXR1cm4gcWkuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpLnRoZW4oZmllbGRzID0+IHtcbiAgICBkZWxldGUgZmllbGRzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgY29uc3Qgc3FsID0gcWkuUXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBmaWVsZHMpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoJzsnKS5maWx0ZXIocSA9PiBxICE9PSAnJyk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5lYWNoKHN1YlF1ZXJpZXMsIHN1YlF1ZXJ5ID0+IHFpLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgT2JqZWN0LmFzc2lnbih7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSkpO1xuICB9KTtcbn1cbmV4cG9ydHMucmVtb3ZlQ29sdW1uID0gcmVtb3ZlQ29sdW1uO1xuXG4vKipcbiAgQSB3cmFwcGVyIHRoYXQgZml4ZXMgU1FMaXRlJ3MgaW5hYmlsaXR5IHRvIGNoYW5nZSBjb2x1bW5zIGZyb20gZXhpc3RpbmcgdGFibGVzLlxuICBJdCB3aWxsIGNyZWF0ZSBhIGJhY2t1cCBvZiB0aGUgdGFibGUsIGRyb3AgdGhlIHRhYmxlIGFmdGVyd2FyZHMgYW5kIGNyZWF0ZSBhXG4gIG5ldyB0YWJsZSB3aXRoIHRoZSBzYW1lIG5hbWUgYnV0IHdpdGggYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSByZXNwZWN0aXZlIGNvbHVtbi5cblxuICBAcGFyYW0gIHtRdWVyeUludGVyZmFjZX0gcWlcbiAgQHBhcmFtICB7c3RyaW5nfSB0YWJsZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhYmxlLlxuICBAcGFyYW0gIHtPYmplY3R9IGF0dHJpYnV0ZXMgQW4gb2JqZWN0IHdpdGggdGhlIGF0dHJpYnV0ZSdzIG5hbWUgYXMga2V5IGFuZCBpdHMgb3B0aW9ucyBhcyB2YWx1ZSBvYmplY3QuXG4gIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICBAcGFyYW0gIHtib29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nXSBBIGZ1bmN0aW9uIHRoYXQgbG9ncyB0aGUgc3FsIHF1ZXJpZXMsIG9yIGZhbHNlIGZvciBleHBsaWNpdGx5IG5vdCBsb2dnaW5nIHRoZXNlIHF1ZXJpZXNcblxuICBAc2luY2UgMS42LjBcbiAgQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hhbmdlQ29sdW1uKHFpLCB0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgYXR0cmlidXRlTmFtZSA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpWzBdO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICByZXR1cm4gcWkuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpLnRoZW4oZmllbGRzID0+IHtcbiAgICBmaWVsZHNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgY29uc3Qgc3FsID0gcWkuUXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBmaWVsZHMpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoJzsnKS5maWx0ZXIocSA9PiBxICE9PSAnJyk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5lYWNoKHN1YlF1ZXJpZXMsIHN1YlF1ZXJ5ID0+IHFpLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgT2JqZWN0LmFzc2lnbih7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSkpO1xuICB9KTtcbn1cbmV4cG9ydHMuY2hhbmdlQ29sdW1uID0gY2hhbmdlQ29sdW1uO1xuXG4vKipcbiAgQSB3cmFwcGVyIHRoYXQgZml4ZXMgU1FMaXRlJ3MgaW5hYmlsaXR5IHRvIHJlbmFtZSBjb2x1bW5zIGZyb20gZXhpc3RpbmcgdGFibGVzLlxuICBJdCB3aWxsIGNyZWF0ZSBhIGJhY2t1cCBvZiB0aGUgdGFibGUsIGRyb3AgdGhlIHRhYmxlIGFmdGVyd2FyZHMgYW5kIGNyZWF0ZSBhXG4gIG5ldyB0YWJsZSB3aXRoIHRoZSBzYW1lIG5hbWUgYnV0IHdpdGggYSByZW5hbWVkIHZlcnNpb24gb2YgdGhlIHJlc3BlY3RpdmUgY29sdW1uLlxuXG4gIEBwYXJhbSAge1F1ZXJ5SW50ZXJmYWNlfSBxaVxuICBAcGFyYW0gIHtzdHJpbmd9IHRhYmxlTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFibGUuXG4gIEBwYXJhbSAge3N0cmluZ30gYXR0ck5hbWVCZWZvcmUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBiZWZvcmUgaXQgd2FzIHJlbmFtZWQuXG4gIEBwYXJhbSAge3N0cmluZ30gYXR0ck5hbWVBZnRlciBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGFmdGVyIGl0IHdhcyByZW5hbWVkLlxuICBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgQHBhcmFtICB7Ym9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZ10gQSBmdW5jdGlvbiB0aGF0IGxvZ3MgdGhlIHNxbCBxdWVyaWVzLCBvciBmYWxzZSBmb3IgZXhwbGljaXRseSBub3QgbG9nZ2luZyB0aGVzZSBxdWVyaWVzXG5cbiAgQHNpbmNlIDEuNi4wXG4gIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbmFtZUNvbHVtbihxaSwgdGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgYXR0ck5hbWVBZnRlciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICByZXR1cm4gcWkuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpLnRoZW4oZmllbGRzID0+IHtcbiAgICBmaWVsZHNbYXR0ck5hbWVBZnRlcl0gPSBfLmNsb25lKGZpZWxkc1thdHRyTmFtZUJlZm9yZV0pO1xuICAgIGRlbGV0ZSBmaWVsZHNbYXR0ck5hbWVCZWZvcmVdO1xuXG4gICAgY29uc3Qgc3FsID0gcWkuUXVlcnlHZW5lcmF0b3IucmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgYXR0ck5hbWVBZnRlciwgZmllbGRzKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KCc7JykuZmlsdGVyKHEgPT4gcSAhPT0gJycpO1xuXG4gICAgcmV0dXJuIFByb21pc2UuZWFjaChzdWJRdWVyaWVzLCBzdWJRdWVyeSA9PiBxaS5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIE9iamVjdC5hc3NpZ24oeyByYXc6IHRydWUgfSwgb3B0aW9ucykpKTtcbiAgfSk7XG59XG5leHBvcnRzLnJlbmFtZUNvbHVtbiA9IHJlbmFtZUNvbHVtbjtcblxuLyoqXG4gKiBAcGFyYW0ge1F1ZXJ5SW50ZXJmYWNlfSBxaVxuICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnN0cmFpbnROYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNvbnN0cmFpbnQocWksIHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpIHtcbiAgbGV0IGNyZWF0ZVRhYmxlU3FsO1xuXG4gIHJldHVybiBxaS5zaG93Q29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKVxuICAgIC50aGVuKGNvbnN0cmFpbnRzID0+IHtcbiAgICAgIC8vIHNxbGl0ZSBjYW4ndCBzaG93IG9ubHkgb25lIGNvbnN0cmFpbnQsIHNvIHdlIGZpbmQgaGVyZSB0aGUgb25lIHRvIHJlbW92ZVxuICAgICAgY29uc3QgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzLmZpbmQoY29uc3RhaW50ID0+IGNvbnN0YWludC5jb25zdHJhaW50TmFtZSA9PT0gY29uc3RyYWludE5hbWUpO1xuXG4gICAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgICBjcmVhdGVUYWJsZVNxbCA9IGNvbnN0cmFpbnQuc3FsO1xuICAgICAgICBjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lID0gcWkuUXVlcnlHZW5lcmF0b3IucXVvdGVJZGVudGlmaWVyKGNvbnN0cmFpbnQuY29uc3RyYWludE5hbWUpO1xuICAgICAgICBsZXQgY29uc3RyYWludFNuaXBwZXQgPSBgLCBDT05TVFJBSU5UICR7Y29uc3RyYWludC5jb25zdHJhaW50TmFtZX0gJHtjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlfSAke2NvbnN0cmFpbnQuY29uc3RyYWludENvbmRpdGlvbn1gO1xuXG4gICAgICAgIGlmIChjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlID09PSAnRk9SRUlHTiBLRVknKSB7XG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlVGFibGVOYW1lID0gcWkuUXVlcnlHZW5lcmF0b3IucXVvdGVUYWJsZShjb25zdHJhaW50LnJlZmVyZW5jZVRhYmxlTmFtZSk7XG4gICAgICAgICAgY29uc3RyYWludC5yZWZlcmVuY2VUYWJsZUtleXMgPSBjb25zdHJhaW50LnJlZmVyZW5jZVRhYmxlS2V5cy5tYXAoY29sdW1uTmFtZSA9PiBxaS5RdWVyeUdlbmVyYXRvci5xdW90ZUlkZW50aWZpZXIoY29sdW1uTmFtZSkpO1xuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZVRhYmxlS2V5cyA9IGNvbnN0cmFpbnQucmVmZXJlbmNlVGFibGVLZXlzLmpvaW4oJywgJyk7XG4gICAgICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBSRUZFUkVOQ0VTICR7cmVmZXJlbmNlVGFibGVOYW1lfSAoJHtyZWZlcmVuY2VUYWJsZUtleXN9KWA7XG4gICAgICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBPTiBVUERBVEUgJHtjb25zdHJhaW50LnVwZGF0ZUFjdGlvbn1gO1xuICAgICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgT04gREVMRVRFICR7Y29uc3RyYWludC5kZWxldGVBY3Rpb259YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNyZWF0ZVRhYmxlU3FsID0gY3JlYXRlVGFibGVTcWwucmVwbGFjZShjb25zdHJhaW50U25pcHBldCwgJycpO1xuICAgICAgICBjcmVhdGVUYWJsZVNxbCArPSAnOyc7XG5cbiAgICAgICAgcmV0dXJuIHFpLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBDb25zdHJhaW50ICR7Y29uc3RyYWludE5hbWV9IG9uIHRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGAsXG4gICAgICAgIGNvbnN0cmFpbnQ6IGNvbnN0cmFpbnROYW1lLFxuICAgICAgICB0YWJsZTogdGFibGVOYW1lXG4gICAgICB9KTtcbiAgICB9KVxuICAgIC50aGVuKGZpZWxkcyA9PiB7XG4gICAgICBjb25zdCBzcWwgPSBxaS5RdWVyeUdlbmVyYXRvci5fYWx0ZXJDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBmaWVsZHMsIGNyZWF0ZVRhYmxlU3FsKTtcbiAgICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoJzsnKS5maWx0ZXIocSA9PiBxICE9PSAnJyk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmVhY2goc3ViUXVlcmllcywgc3ViUXVlcnkgPT4gcWkuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCBPYmplY3QuYXNzaWduKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlbW92ZUNvbnN0cmFpbnQgPSByZW1vdmVDb25zdHJhaW50O1xuXG4vKipcbiAqIEBwYXJhbSB7UXVlcnlJbnRlcmZhY2V9IHFpXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZENvbnN0cmFpbnQocWksIHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICBjb25zdCBjb25zdHJhaW50U25pcHBldCA9IHFpLlF1ZXJ5R2VuZXJhdG9yLmdldENvbnN0cmFpbnRTbmlwcGV0KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGRlc2NyaWJlQ3JlYXRlVGFibGVTcWwgPSBxaS5RdWVyeUdlbmVyYXRvci5kZXNjcmliZUNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lKTtcbiAgbGV0IGNyZWF0ZVRhYmxlU3FsO1xuXG4gIHJldHVybiBxaS5zZXF1ZWxpemUucXVlcnkoZGVzY3JpYmVDcmVhdGVUYWJsZVNxbCwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVCwgcmF3OiB0cnVlIH0pKVxuICAgIC50aGVuKGNvbnN0cmFpbnRzID0+IHtcbiAgICAgIGNvbnN0IHNxbCA9IGNvbnN0cmFpbnRzWzBdLnNxbDtcbiAgICAgIGNvbnN0IGluZGV4ID0gc3FsLmxlbmd0aCAtIDE7XG4gICAgICAvL1JlcGxhY2UgZW5kaW5nICcpJyB3aXRoIGNvbnN0cmFpbnQgc25pcHBldCAtIFNpbXVsYXRlcyBTdHJpbmcucmVwbGFjZUF0XG4gICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQzMTA5NFxuICAgICAgY3JlYXRlVGFibGVTcWwgPSBgJHtzcWwuc3Vic3RyKDAsIGluZGV4KX0sICR7Y29uc3RyYWludFNuaXBwZXR9KSR7c3FsLnN1YnN0cihpbmRleCArIDEpfTtgO1xuXG4gICAgICByZXR1cm4gcWkuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIH0pXG4gICAgLnRoZW4oZmllbGRzID0+IHtcbiAgICAgIGNvbnN0IHNxbCA9IHFpLlF1ZXJ5R2VuZXJhdG9yLl9hbHRlckNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGZpZWxkcywgY3JlYXRlVGFibGVTcWwpO1xuICAgICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdCgnOycpLmZpbHRlcihxID0+IHEgIT09ICcnKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UuZWFjaChzdWJRdWVyaWVzLCBzdWJRdWVyeSA9PiBxaS5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIE9iamVjdC5hc3NpZ24oeyByYXc6IHRydWUgfSwgb3B0aW9ucykpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYWRkQ29uc3RyYWludCA9IGFkZENvbnN0cmFpbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtRdWVyeUludGVyZmFjZX0gcWlcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBRdWVyeSBPcHRpb25zXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5mdW5jdGlvbiBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHFpLCB0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YWJhc2UgPSBxaS5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlO1xuICBjb25zdCBxdWVyeSA9IHFpLlF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lLCBkYXRhYmFzZSk7XG4gIHJldHVybiBxaS5zZXF1ZWxpemUucXVlcnkocXVlcnksIG9wdGlvbnMpXG4gICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQubWFwKHJvdyA9PiAoe1xuICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgIGNvbHVtbk5hbWU6IHJvdy5mcm9tLFxuICAgICAgICByZWZlcmVuY2VkVGFibGVOYW1lOiByb3cudGFibGUsXG4gICAgICAgIHJlZmVyZW5jZWRDb2x1bW5OYW1lOiByb3cudG8sXG4gICAgICAgIHRhYmxlQ2F0YWxvZzogZGF0YWJhc2UsXG4gICAgICAgIHJlZmVyZW5jZWRUYWJsZUNhdGFsb2c6IGRhdGFiYXNlXG4gICAgICB9KSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydHMuZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSA9IGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGU7XG4iXX0=